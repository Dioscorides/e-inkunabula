{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to e-Inkunabula","text":"<p>Info</p> <p>This project's aim is to create a guide that will help you through the process of setting up your own e-ink display using a Raspberry Pi, a WaveShare 9.7\" e-ink display, and Home Assistant.</p> <pre><code>sequenceDiagram\n    NAS-&gt;&gt;NAS: Generates a screenshot&lt;br/&gt;of the Home Assistant view\n    Raspberry Pi--&gt;&gt;NAS: Screenshot requested&lt;br/&gt;by the Raspberry Pi\n    NAS-&gt;&gt;Raspberry Pi: Screenshot imported&lt;br/&gt; by the Raspberry Pi\n    InkyCal--&gt;&gt;Raspberry Pi: Image requested&lt;br/&gt;by InkyCal\n    Raspberry Pi-&gt;&gt;InkyCal: Screenshot imported&lt;br/&gt; to InkyCal\n    InkyCal-&gt;&gt;InkyCal: Screenshot converted&lt;br/&gt;to a displayable image by InkyCal\n    InkyCal-)WaveShare 9.7\" E-Ink Display: Image sent&lt;br/&gt;to the e-ink display\n</code></pre> <p>Want to skip the preamble?  Let's get started with the installation! </p>"},{"location":"#concept","title":"Concept","text":"<p>E-ink displays are a great way to display information: they are easy on the eyes, and they only use power when the display is updated. This makes them perfect for displaying information that does not change often, such as the weather forecast, the current time, or the current date, or any other information that you would like to display coming from Home Assistant.</p> <p>Yet, buying an e-ink screen, connecting it to a Raspberry Pi, and displaying information from Home Assistant on it is not as easy as it sounds: There are many different e-ink screens available, and they all have their own quirks. Some e-ink displays are touchscreens, some are not; some e-ink displays are connected to the Raspberry Pi using the 40-pin GPIO header, some are connected using the SPI interface; some e-ink displays are compatible with the WaveShare ESP32 driver board, some are not, and the list goes on.</p> <p>This projects aims to help you through the process of setting up your own e-ink display using a Raspberry Pi, a WaveShare 9.7\" e-ink display, and Home Assistant in the simplest way we could find.</p> <p>Warning</p> <p>This project is meant for e-ink displays that can display HD images at 16bit Grayscale, such as the WaveShare 9.7\" e-ink display. If you are using a e-ink display that can only display images at 8bit grayscale or less, such as the WaveShare 7.5\" e-ink display, you should follow the guide offered by InkyCal instead.</p>"},{"location":"#logic","title":"Logic","text":"<p>e-Inkunabula's logic is the following:</p> <ol> <li>Home Assistant Lovelace Kindle Screensaver will take a screenshot of \"kiosked\" Home Assistant view.</li> <li>A python script on the Raspberry Pi will fetch the latest screenshot from the Synology NAS.</li> <li>InkyCal will process and send the image to the e-ink display.</li> </ol> <p>This documentation will help you through the process in detail and guide you through the process of setting up your own e-ink display!</p>"},{"location":"#projects-name","title":"Project's name","text":"<p>This project's name - e-Inkunabula - is a play on the words \"e-ink\" and \"incunabula\": Incunabula are books printed using metal type from before 1501, and e-ink is the technology used for the display used in this project.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#hardware","title":"Hardware","text":"<ol> <li>Connect the IT8951 driver board to the Raspberry Pi using the 40-pin GPIO header.</li> <li>Connect the WaveShare 9.7\" e-ink display to the 9.7\" e-ink display adapter, and connect the 9.7\" e-ink display adapter to the IT8951 driver board using the FPC cable<sup>1</sup>. The FPC cable is the orange cable at the bottom of your display.</li> </ol>"},{"location":"installation/#software","title":"Software","text":"<p>This guide is structured as follows:</p> <ul> <li>Step 1 - Setting up Home Assistant and Kiosk Mode - We will use Home Assistant in \"Kiosk mode\" to create a view that is optimized for our e-ink display.</li> <li>Step 2 - Setting up Home Assistant Lovelace Kindle Screensaver - We will use Home Assistant Lovelace Kindle Screensaver to take a screenshot of our Home Assistant view.</li> <li>Step 3 - Setting up the Raspberry Pi and Step 4 - Installing Inkycal on the Raspberry Pi - Next we will set up the Raspberry Pi and install Inkycal on it.</li> <li>Step 5 - Modifying Inkycal's files and Step 6 - Import your screenshot to the Raspberry Pi and autostarting - Finally, we will use a Python script to fetch the screenshot from the server to the Raspberry Pi and display it on the e-ink display.</li> </ul>"},{"location":"installation/#important-notes-before-you-start","title":"Important notes before you start","text":"<p>This guide assumes you have Home Assistant (HA) already up and running. In this guide Home Assistant instance is running on a Synology DS218+ NAS, but the workflow should work if you are running HA in other ways as well.</p> <p>We will also reference to Portainer. Portainer is a Docker management tool that makes it easier to manage Docker containers and we will use is to create a stack to run Home Assistant Lovelace Kindle Screensaver. You can use Synology's Container Manager to create a stack too, but Portainer is easier to use<sup>2</sup> and the Community Edition (CE) is free.</p>"},{"location":"installation/#step-1-setting-up-home-assistant-and-kiosk-mode","title":"Step 1 - Setting up Home Assistant and Kiosk Mode","text":"<p>This is not strictly necessary, but we recommend setting up a dedicated view in Home Assistant for your e-ink display using \"Kiosk Mode\". This will allow you to create a view that is optimized for your e-ink display by removing unnecessary elements, such as the sidebar and the header.</p> <p>While out of the scope of this guide, here is a quick guide on how to install HACS for Home Assistant running on a Synology NAS:</p> <ol> <li>Manually download the latest version of HACS from this link: HACS Releases.</li> <li>After downloading, unzip the contents of the <code>hacs.zip</code> file on your computer.</li> <li>Using Synology's \"File Station\", locate your Home Assistant docker installation directory, usually located in the <code>/volume1/docker/</code> folder.</li> <li>Navigate to the <code>custom_components</code> folder within your Home Assistant directory.</li> <li>Copy the contents of the unzipped HACS folder into the custom_components/hacs directory.</li> <li>Restart your Home Assistant server to apply the changes.</li> <li>Open your Home Assistant web interface.</li> <li>Navigate to \"Configuration\" and then \"Integrations.\"</li> <li>Search for the HACS integration and activate it.</li> </ol> <p>If you know how to SSH directly into your Home Assistant docker container, you can also install HACS using the following command - although you might encounter issues we are not covering in this guide:</p> <pre><code>wget -O - https://get.hacs.xyz | bash -\n</code></pre> <p>Refer to the HACS Documentation for additional guidance on initial configuration and how to view a \"kiosked\" view in Home Assistant.</p> <p>If the HACS integration does not appear:</p> <ol> <li>Try using a different web browser.</li> <li>Clear your browser cache and attempt the search again.</li> </ol> <p>Open HACS by clicking \"HACS\" on the Home Assistant sidebar, and install Kiosk Mode. Have fun creating a view that is optimized for your e-ink display!</p> <p>Tip</p> <p>Consider also installing layout-card using HACS for more control on how your view is displayed.</p>"},{"location":"installation/#step-2-setting-up-home-assistant-lovelace-kindle-screensaver","title":"Step 2 - Setting up Home Assistant Lovelace Kindle Screensaver","text":"<p>Now that we have a dedicated view for our e-ink display, we want to take screenshots of it. We are going to use Home Assistant Lovelace Kindle Screensaver via a docker container to achieve this.</p> <p>Note</p> <p>As mentioned earlier, we will be using Portainer for this step.</p> <ol> <li>Create a new folder in your Synology NAS. We will use <code>/volume1/docker/screenshotter</code> in this guide.</li> <li> <p>Got to your Portainer instance and create a new stack. You can do this by clicking on <code>Stacks</code> in the left sidebar, and then clicking on <code>Add stack</code>:</p> <ul> <li>Give your stack a name. We will use <code>screenshotter</code>.</li> <li>As <code>Build method</code> select <code>Web editor</code>.</li> <li>In the <code>Web editor</code> field, copy and paste the following code:</li> </ul> <pre><code>version: \"3.8\"\n\nservices:\n  app:\n    image: sibbl/hass-lovelace-kindle-screensaver:latest\n    environment:\n      - HA_BASE_URL=http://YOUR_LOCAL_HOME_ASSISTANT_IP:PORT\n      - HA_SCREENSHOT_URL=/dashboard-kiosk/default_view?kiosk\n      - HA_ACCESS_TOKEN=\n      - CRON_JOB=*/1 * * * *\n      - RENDERING_TIMEOUT=30000\n      - RENDERING_DELAY=0\n      - RENDERING_SCREEN_HEIGHT=805\n      - RENDERING_SCREEN_WIDTH=1150\n      - COLOR_MODE=TrueColor\n      - GRAYSCALE_DEPTH=16\n      - OUTPUT_PATH=/output/image.png\n      - LANGUAGE=en\n    deploy:\n      restart_policy:\n        condition: on-failure\n        delay: 5s\n        max_attempts: 3\n        window: 120s\n\n    ports:\n      - 7799:5000\n    volumes:\n      - /volume1/docker/screenshotter/output:/output:rw\n</code></pre> <p>Be mindful of the indentations.</p> <p>An explanation of the different fields:</p> <ul> <li><code>image</code>: The image that will be used to run the container. We will use <code>sibbl/    hass-lovelace-kindle-screensaver:latest</code> in this guide. <code>latest</code> is version 1.0.5   at the time of writing.</li> <li><code>HA_BASE_URL</code>: The URL of your local Home Assistant instance.</li> <li><code>HA_SCREENSHOT_URL</code>: The path of the view you want to take a screenshot of.</li> <li><code>HA_ACCESS_TOKEN</code>: The access token of your Home Assistant instance. See Creating    a Home Assistant Access Token for more   information.</li> <li><code>CRON_JOB</code>: The cron job that will be used to take a screenshot of your Home  Assistant view. The default value is <code>*/1 * * * *</code>, which means that a screenshot    will be taken every minute. You can change this value to your liking.</li> <li><code>RENDERING_TIMEOUT</code>: The timeout for the screenshot. The default value is <code>30000</code>,    which means that the screenshot will timeout after 30 seconds. You can change this     value to your liking.</li> <li><code>RENDERING_DELAY</code>: The delay before the screenshot is taken. The default value is     <code>0</code>. In our case, changing this value resulted in HA's cards not being rendered     correctly, so we left it at <code>0</code>.</li> <li><code>RENDERING_SCREEN_HEIGHT</code>: The height of the screenshot. Check the specifications     of your e-ink display to find out what the height of your display is. From there,   experiment with different values to find out what works best for you.</li> <li><code>RENDERING_SCREEN_WIDTH</code>: The width of the screenshot. Same as above.</li> <li><code>COLOR_MODE</code>: The color mode of the screenshot. Since our WaveShare 9.7\" e-ink    display can display HD images at 16bit Grayscale, we set this value to <code>TrueColor</code> as  the screen is capable of rendering the various shades of colors transformed to gray.</li> <li><code>GRAYSCALE_DEPTH</code>: The grayscale depth of the screenshot. Since our WaveShare 9.7\"    e-ink display can display HD images at 16bit Grayscale, we set this value to <code>16</code>  (optional).</li> <li><code>OUTPUT_PATH</code>: The path where the screenshot will be saved. We will use <code>/output/ image.png</code> in this guide.</li> <li><code>LANGUAGE</code>: The language of the screenshot. We will use <code>en</code> in this guide    (optional).</li> <li><code>restart_policy</code>: The restart policy of the container. We are using <code>on-failure</code>,     with a <code>delay</code> of <code>5s</code>, <code>max_attempts</code> of <code>3</code>, and a <code>window</code> of <code>120s</code> in this case.   This means that the container will be restarted if it fails, with a delay of 5    seconds between each attempt, a maximum of 3 attempts, and a window of 120 seconds. You can change these values to your liking.</li> <li><code>ports</code>: The port that will be used to access the container. We will use <code>7799</code> in this guide.</li> <li>Click on <code>Deploy stack</code>.</li> <li>Navigate to <code>http://YOUR_LOCAL_HOME_ASSISTANT_IP:7799</code> to check if the container is running correctly. You should see a screenshot of the Home Assistant view you specified in the <code>HA_SCREENSHOT_URL</code> field.</li> </ul> </li> </ol>"},{"location":"installation/#creating-a-home-assistant-access-token","title":"Creating a Home Assistant Access Token","text":"<p>The easiest way to create a Home Assistant access token is to use the navigate to your Home Assistant instance, login as an administrator, click on your profile picture in the bottom left corner, scroll down to the <code>Long-Lived Access Tokens</code> section, and click on <code>Create Token</code>. Give your token a name, and copy the token to your clipboard. Paste the token in the <code>HA_ACCESS_TOKEN</code> field in the Portainer stack here above.</p>"},{"location":"installation/#step-3-setting-up-the-raspberry-pi","title":"Step 3 - Setting up the Raspberry Pi","text":"<p>We finally have an image of a Home Assistant dashboard. Now we \"just\" need to display it on our e-ink display! First up, we need to install Raspberry Pi OS on our Raspberry Pi:</p> <ul> <li>Install Raspberry Pi OS using Raspberry Pi Imager. Follow the on-screen instructions and make sure you pre-configure your WiFi settings and enable SSH.</li> </ul> <p>Tip</p> <p>Note down your <code>hostname</code>, <code>username</code>, and <code>password</code> you have chosen, as you will need them to SSH into your Raspberry Pi later on. You can find more information about how to SSH into your Raspberry Pi here.</p> <p>After installing Raspberry Pi OS, boot your Raspberry Pi and try to SSH into using, as an example, Terminus or Solar-PuTTY.</p>"},{"location":"installation/#step-4-installing-inkycal-on-the-raspberry-pi","title":"Step 4 - Installing Inkycal on the Raspberry Pi","text":"<p>We have the screenshot, we have a working Raspberry Pi. Now it's time to install Inkycal on the Raspberry Pi: a Python application that will allow us to display the screenshot on our e-ink display.</p> <p>Warning</p> <p>We are using Inkycal v.2.0.2 specifically! Inkycal is in constant development, and the issues encountered in this guide might have been fixed already. If you are using a different version, the files we are going to edit might be different.</p> <p>Warning</p> <p>You might encounter issues while installing Inkycal on your Raspberry Pi. Check the Troubleshooting section for more information.</p> <ol> <li>Follow the instructions at Inkycal's GitHub page to install Inkycal on your Raspberry Pi.</li> <li> <p>Step 2 on the Inkcal's guide will tell you to create a <code>settings.json</code> file to flash in the <code>/boot</code> folder, using their web-ui. Do so, and fill the fields with the information that applies to your case.    In the <code>Modules config</code> area you should add only 1 module: <code>Inkycal Image</code>, with a <code>Module height (by ratio)</code> of <code>1</code>. Click on <code>Generate settings file</code> and download the <code>settings.json</code> file.</p> <p>For reference, the following is the <code>settings.json</code> we'll be using for this guide:</p> <pre><code>{\n    \"model\": \"9_in_7\",\n    \"update_interval\": 15,\n    \"orientation\": 0,\n    \"info_section\": true,\n    \"info_section_height\": 30,\n    \"border_around_modules\": false,\n    \"calibration_hours\": [\n        2,\n        6,\n        12\n    ],\n    \"modules\": [\n        {\n            \"position\": 1,\n            \"name\": \"Inkyimage\",\n            \"config\": {\n                \"size\": [\n                    825,\n                    1170\n                ],\n                \"path\": \"/home/pi/screenshots/image.png\",\n                \"palette\": \"bw\",\n                \"autoflip\": true,\n                \"orientation\": \"vertical\",\n                \"padding_x\": 10,\n                \"padding_y\": 10,\n                \"fontsize\": 12,\n                \"language\": \"en\"\n            }\n        }\n    ]\n}\n</code></pre> </li> <li> <p>Carefully follow Inkycal's instructions on step <code>6.</code>.    This step mentions that <code>If you have the 12.48\" display, these steps are also required:</code>, but this also applies to our 9.7\" screen:    Use the following commands to install the BCM2835 library on the Raspberry Pi. Load the terminal on the Raspberry Pi via SSH and type the following commands:</p> <pre><code>wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.xx.tar.gz\ntar zxvf bcm2835-1.xx.tar.gz\ncd bcm2835-1.xx/\nsudo ./configure\nsudo make\nsudo make check\nsudo make install\n</code></pre> <ul> <li>Replace <code>1.xx</code> with the version number of the library that you downloaded. <code>1.73</code> at the time of writing.</li> <li><code>./configure</code>: This command runs a script that checks the system for any necessary dependencies and configures the library for the system.</li> <li><code>make</code>: This command compiles the library.</li> <li><code>sudo make check</code>: This command runs a set of tests to ensure that the library was compiled correctly.</li> <li><code>sudo make install</code>: This command installs the library on the system.</li> </ul> <p>Next, install <code>WiringPi</code>:</p> <pre><code>wget https://project-downloads.drogon.net/wiringpi-latest.deb\nsudo dpkg -i wiringpi-latest.deb\n</code></pre> </li> <li> <p>Next, follow the instructions in the \"Manual installation\" section.</p> </li> </ol> <p>Tip</p> <p>This is where you might encounter issues. Specifically, you might encounter issues while installing <code>numpy</code> and <code>matplotlib</code> while running the <code>pip install -e ./</code> command. If you do, follow the instructions in the Troubleshooting section.</p> <p>Danger</p> <p>If you were able to successfully install Ikycal we strongly advise against running it just yet! The default settings have a VCOM hardcoded to 2.00 which might be too high for your e-ink display and might cause ghosting in the long term. We will fix this in the next steps.</p>"},{"location":"installation/#step-5-modifying-inkycals-files","title":"Step 5 - Modifying Inkycal's files","text":"<p>You are almost there! Once you have successfully installed Inkycal, you need to modify some of its files to make sure it works correctly with your e-ink display.</p> <ol> <li>Adapt the VCOM value being passed to the e-ink display which might in its original value might cause ghosting in the long run.</li> <li>Fix the hardcoded <code>.convert('1', dither=dither)</code> value that forces the image to be converted to bilevel (black and white only), using dither to simulate grayscale.</li> </ol>"},{"location":"installation/#step-51-adapting-the-vcom","title":"Step 5.1: Adapting the VCOM","text":"<p>The official WaveShare documentation is very clear about this:</p> <p>Quote</p> <p>The VCOM value of each E-paper has certain differences. The VCOM value of each E-paper is marked on the FPC cable, so make sure the correct VCOM value is used in each execution of the demo, otherwise, the display will become worse if the E-paper works under the wrong VCOM value for a long time<sup>3</sup>.</p> <p>What WaveShare means is that if the e-ink display runs using the wrong VCOM for an extended period of time, it will burn in; the screen will not be able to refresh itself properly and you will experience irreversible ghosting.</p> <p>The drivers used by Inkycal use a default hardcoded value. In the case of the 9.7\" inch driver, it is set to <code>2.00</code>.</p> <p>Check the VCOM value on the FPC of your e-ink display. The FPC is the orange cable at the bottom of your display. The VCOM value is printed on the FPC in rather small letters and starts with a <code>-</code> (minus). On newer models it is printed on top of a QR code. In our case the value visible was <code>-1.81</code></p> <p>On your Raspberry Pi, navigate to your display's driver. In this case we will edit the 9.7\" driver in <code>/home/pi/Inkycal/inkycal/display/drivers/9_in_7.py</code>. Find the <code>VCOM = \"2.00</code>. Replace <code>2.00</code> with the VCOM value of your display. In our case: <code>1.81</code>. Note that it is not necessary to add the minus <code>-</code>; it is added later in the same script.</p> <p>Save the edited script.</p>"},{"location":"installation/#step-52-saving-the-image-in-the-right-format-for-the-display","title":"Step 5.2: Saving the image in the right format for the display","text":"<p>Inkycal's <code>main.py</code> describes the attributes of the <code>main</code> class with the following statement:</p> <pre><code>\"\"\"\nAttributes:\n  - optimize = True/False. Reduce number of colours on the generated image\n    to improve rendering on E-Papers. Set this to False for 9.7\" E-Paper.\n\"\"\"\n</code></pre> <p>Yet, in the same file, we see that in TODO: ADD EXACT LINE, we see a hardcoded variable:</p> <pre><code># Option to use epaper image optimisation, reduces colours\nself.optimize = True\n</code></pre> <p>This will always reduce the quality of the images before sending them to the e-ink display. Switch the statement to <code>False</code> to fix this:</p> <pre><code>self.optimize = False\n</code></pre> <p>Next, it is crucial that you edit the Inkcal \"Image\" module at <code>/home/pi/Inkycal/inkycal/modules/inky_image.py</code>. In this file, find the following line of code:</p> <pre><code>im_black = image.convert('1', dither=dither)\n</code></pre> <p>This means that the the script will always attempt to convert the image to a bilinear black and white image. There will be no grayscale, rather the shades of gray will be emulated using dither: a technique that uses a pattern of dots to simulate shades of gray.</p> <p>Change this value to:</p> <pre><code>im_black = image.convert('RGB')\n</code></pre> <p>For more information about the different image modes, check Pillow's documentation.</p>"},{"location":"installation/#step-6-import-your-screenshot-to-the-raspberry-pi-and-autostarting","title":"Step 6 - Import your screenshot to the Raspberry Pi and autostarting","text":"<ol> <li>Using your favorite SFTP client, connect to your Raspberry Pi, using the same credentials used for the SSH connection, and navigate to the <code>/home/pi/screenshots</code> folder.</li> <li>Upload the <code>fetch_image.py</code> in the <code>raspberry_pi/screenshots</code> folder of this repository to the <code>/home/pi/screenshots</code> folder on your Raspberry Pi.</li> <li>Run the script.</li> </ol> <p>You should see a new <code>image.png</code> file in the <code>/home/pi/screenshots</code> folder!</p> <p>Important</p> <p>You must make sure that this script runs when you start your Raspberry Pi, and that it runs regularl using Cron and the command <code>sudo crontab -e</code>. For example:</p> <pre><code>*/3 * * * * python3 /home/pi/screenshots/fetch_image.py\n@reboot python3 /home/pi/screenshots/fetch_image.py\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#inkycal-get-stuck-while-installing-or-the-installation-seems-to-take-hours","title":"Inkycal get stuck while installing, or the installation seems to take hours","text":"<p>This is a known issue. You can find more information about it here. We solved it like this:</p> <ol> <li> <p>Increase the swapfile size on your Raspberry Pi: SSH to your Raspberry Pi and run the following commands, line by line. This will increase the swapfile size to 256MB.</p> <pre><code>sudo dphys-swapfile swapoff\nsudo nano /etc/dphys-swapfile\nsudo sed -i -E '/^CONF_SWAPSIZE=/s/=.*/=256/' /etc/dphys-swapfile\nsudo dphys-swapfile setup\nsudo dphys-swapfile swapon\n</code></pre> </li> <li> <p>Reboot your Raspberry Pi.</p> </li> <li> <p>You will notice that the ticket linked above mentions installing <code>numpy</code> and <code>matplotlib</code> separately and individually. In our case, we were not able to install them because of missing BLAS libraries. We solved this by installing the following package:</p> <pre><code>cd ~/Inkycal &amp;&amp; source venv/bin/activate\nsudo apt install libopenblas-dev\npip install --upgrade --verbose --no-cache-dir numpy\npip install --upgrade --verbose --no-cache-dir matplotlib\npip install -e --verbose ./\n</code></pre> <p>These installation can take a long time (30+ minutes) and might seem stuck. That is why we added the <code>--verbose</code> flag to the <code>pip install</code> commands: this will show you the progress of the installation.</p> </li> </ol> <ol> <li> <p>You can connect the FPC cable directly to the IT8951 driver board, but this is not recommended as it is more difficult to move the Raspberry Pi around and, later on, hide it in a case.\u00a0\u21a9</p> </li> <li> <p>If you are using Synology's Container Manager, but are interested in Portainer you can follow this excellent guide to install Portainer on your Synology NAS.\u00a0\u21a9</p> </li> <li> <p>Source: WaveShare's Wiki \u21a9</p> </li> </ol>"},{"location":"requirements/","title":"Requirements","text":""},{"location":"requirements/#hardware-used","title":"Hardware used","text":"<p>The hardware used in this project is:</p> <ul> <li>Raspberry Pi 3 v1.2</li> <li>16GB microSD card</li> <li>WaveShare 9.7\" e-ink display</li> <li>WaveShare e-ink display driver board (IT8951)</li> <li>5V 2A power supply</li> <li>Synology DS218+ NAS</li> </ul> <p>The Raspberry Pi and the microSD card are required as they will host and run the necessary scripts to update the e-ink display.</p> <p>The WaveShare 9.7\" e-ink display and the WaveShare IT8951 e-ink display driver board are required. This e-ink displays HD images and requires the additional IT8951 driver board to function.</p> <p>Danger</p> <p>You can neither immediately connect the WaveShare 9.7\" e-ink display directly to the Raspberry Pi nor can you connect the WaveShare ESP32 driver directly to this e-ink display. You need the WaveShare IT8951 e-ink display driver board to connect the e-ink display to either the Raspberry Pi or the ESP32 driver board - and to follow along with this guide.</p>"},{"location":"requirements/#software-used","title":"Software used","text":"<p>The software used in this project is:</p> <ul> <li>Raspbian</li> <li>Python 3.7</li> <li>BCM2835 library</li> <li>WaveShare IT8951 library</li> <li>Docker (running on Synology DS218+)</li> <li>Portainer (via Docker, running on Synology DS218+ - Optional: you can create a stack using the Synology interface directly.)</li> <li>Home Assistant (via Docker, running on Synology DS218+)</li> <li>sibbl/hass-lovelace-kindle-screensaver (via Docker, running on Synology DS218+)</li> <li>Inkycal v.2.0.2</li> </ul> <p>Note</p> <p>We are using Inkycal v.2.0.2 specifically. This is because we are going to edit some files from that project. If you are using a different version, the files we are going to edit might be different - or the issues we fixed might have been fixed already.</p>"}]}